> [!warning] This page is optional

### Conceptually

[[Chapters/Reference/Operations/Recursion|Recursion]] is a way of looping by having a function call itself, and can be used to solve problems involving nested data structures or sequences defined based on their previous terms.

Recursive functions use [[Chapters/Basics/Control Flow/Conditional Statements|Conditional Statements]] to select between a recursive path, calling the function again on a smaller problem, or the base case, in which case it returns without further calling itself.

Looking at some examples:
```py
def multiplication(number, times):
	if times == 1:  # Base case
		return number
	return number + multiplication(number, times - 1)  # Recursive case

assert multiplication(5, 6) == 30
# will error if you try with 0 or a negative value for `times`, as it always counts downwards
# (computers do that way more efficiently when you just use * btw)
```

```py
def sum_tree_leaves(tree):
	total = 0
	for key, value in tree.items():
		if isinstance(value, dict):
			value = sum_tree_leaves(value)
		print(f"Value for {key}: {value}")
		total += value
	return total

tree = {
	"X": {
		"A": 10,
		"B": 2,
	},
	"Y": {
		"Z": {
			"C": 3,
			"D": 4,
		},
		"E": 5,
	}
}
result = sum_tree_leaves(tree)
print(f"Final result: {result}")
```

```py
def flatten(lst):
	result = []
	for element in lst:
		if isinstance(element, list):
			result.extend(flatten(element))
		else:
			result.append(element)
	return result

assert flatten([[1, 2], [3, 4], [[5]], 6]) == [1, 2, 3, 4, 5, 6]

# same function but with comments and print statements:
def flatten(lst):
	"Flattens arbitrary nested lists"
	print(f"Start flattening {lst}")
	result = []
	for element in lst:
		print(f"Current result: {result}")
		if isinstance(element, list):
			# Recursive case: Run the function again for any nested lists it contains, and again if it further contains any, and again, ....
			# (then extends *this* result by the *returned* result, which was generated by the base case within the recursive call)
			print(f"Recursively caling for {element}")
			result.extend(flatten(element))
		else:
			print(f"Appending element {element}")
			# Base case: Appends elements that don't require flattening
			result.append(element)
	print(f"Returning {result}")
	return result


flatten([1, 2, [3, 4, [5, 6, [7], 8], 9], 10])

flatten([1, [[2]], [3, 4, [5, 6, [7], [8]], [], 9], [[], 10]])
```

- Exercise: [[Chapters/Excercises/Numeric Operations Extra 1|Numeric Operations Extra 1]]

### Further Reading

[[Chapters/Reference/Operations/Recursion|Recursion]]